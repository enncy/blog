{"pages":[{"title":"comment-policy 评论协议","text":"欢迎并鼓励在本网站上发表评论，但在某些情况下，评论将被编辑或删除，如下所示： 被视为垃圾邮件或纯粹是促销性质的评论将被删除。允许包含指向相关内容的链接，但评论应与帖子主题相关。 包括脏话在内的评论将被删除。 包含可能被视为冒犯性的语言或概念的评论将被删除。请注意，这可能包括辱骂、威胁、色情、冒犯、误导或诽谤的语言。 直接攻击个人的评论将被删除。 骚扰其他发帖者的评论将被删除。请尊重其他贡献者。 匿名评论将被删除。我们只接受来自表明自己身份的海报的评论。 本博客的所有者保留编辑或删除提交给博客的任何评论的权利，恕不另行通知。此评论政策可能随时更改。如果您对评论政策有任何疑问，请通过 我的联系方式 告诉我。","link":"/comment-policy/index.html"},{"title":"关于","text":"网站 欢迎大家来到我的博客，我会尽量写很多优质的文档或文章分享给大家，感谢关注！ 作者 网名: 言小溪 英文名: enncy (以为这个英文发音很像言小溪，所以… 🤣) 联系方式: github : enncy csdn: 言小溪 知乎: 言小溪 邮箱: enncyemail@qq.com 搭建 网站是由 hexo 博客引擎 和 icarus 主题一同搭建的，并以 github action 来构建，最后使用 github pages 展示。","link":"/about/index.html"}],"posts":[{"title":"置顶文章","text":"欢迎来到我的博客 😁, 有任何问题,请到 关于 页面获取我的联系方式，联系我。","link":"/2022/01/21/%E7%BD%AE%E9%A1%B6%E6%96%87%E7%AB%A0/"},{"title":"Jpptr - 动作(Action)","text":"动作的执行是由 解析器 和 插件 一起协作执行的。 如下动作 1[&quot;goto&quot;, &quot;https://enncy.github.io/jpptr/test.html&quot;] ArrayParser 将其解析成 12345{ &quot;use&quot;: &quot;function&quot;, &quot;name&quot;: &quot;goto&quot;, &quot;args&quot;: [&quot;https://enncy.github.io/jpptr/test.html&quot;]} 最后再由 FunctionPlugin 去执行 puppeteer 方法 1page.goto(&quot;https://enncy.github.io/jpptr/test.html&quot;); 解析器和插件都由 jpptr 默认加载 你可以在动作文件中使用 register 参数进行新的解析器或者插件注册, 甚至可以覆盖原有的默认模块 1234567891011121314151617181920{ &quot;register&quot;:{ &quot;parsers&quot;:[ { &quot;name&quot;:&quot;number-parser&quot;, &quot;parser&quot;:&quot;./number-parser.js&quot; } ], &quot;plugins&quot;:[ { &quot;name&quot;:&quot;goto-plugin&quot;, &quot;plugin&quot;:&quot;./goto-plugin.js&quot; } ] }, &quot;launch&quot;:{...}, &quot;actions&quot;:[]} number-parser.js12345678910module.exports = function NumberParser(action) { if (typeof action === &quot;number&quot;) { if (actions === 1) { return { use: &quot;goto-plugin&quot;, href: &quot;https://example.com&quot;, }; } }}; goto-plugin.js123module.exports = function GotoPlugin(options) { return [[&quot;goto&quot;, options.action.href]];}; 如果有以下动作列表 123{ &quot;actions&quot;: [1, 1]} 使用自定义的 number-parser 和 goto-plugin 将会解析成 1234567891011121314{ &quot;actions&quot;: [ { &quot;use&quot;: &quot;goto-plugin&quot;, &quot;href&quot;: &quot;https://example.com&quot;, &quot;actions&quot;: [[&quot;goto&quot;, &quot;https://example.com&quot;]] }, { &quot;use&quot;: &quot;goto-plugin&quot;, &quot;href&quot;: &quot;https://example.com&quot;, &quot;actions&quot;: [[&quot;goto&quot;, &quot;https://example.com&quot;]] } ]} 流程是这样的 1.jpptr 调用 number-parser 1 变成 {use: &quot;goto-plugin&quot;,href: &quot;https://example.com&quot;} 2.jpptr 调用 goto-plugin {use: &quot;goto-plugin&quot;,href: &quot;https://example.com&quot;} 变成 12345{ &quot;use&quot;: &quot;goto-plugin&quot;, &quot;href&quot;: &quot;https://example.com&quot;, &quot;actions&quot;: [[&quot;goto&quot;, &quot;https://example.com&quot;]]} 原理就是，如果 插件 仅仅返回一个 动作列表 ，则 jpptr 会自动添加 {&quot;actions&quot;:[...]} 的属性, 并且 jpptr 会执行 actions 里面的动作 更多详情请看 插件","link":"/jpptr-docs/action/"},{"title":"Jpptr - 解析器(Parser)","text":"","link":"/jpptr-docs/parser/"},{"title":"Jpptr - 动作(Plugin)","text":"","link":"/jpptr-docs/plugin/"},{"title":"Jpptr文档","text":"一个使用 json 语法糖去执行 puppeteer 的框架。 你可以使用 json 去执行 puppeteer , 就像使用 javascript 去执行 puppeteer 一样 本项目默认您已经了解 puppeteer 以及 nodejs 等框架。 安装 1npm install jpptr 使用命令行 123456# 执行 jpptr 的配置文件npx jpptr &lt;file&gt; [options]# 执行单个带有动作的文件npx jpptr exec &lt;file&gt; [options]# 查看帮助npx jpptr -h 启动配置文件 1234# 启动配置文件, 默认的文件为 jpptr.config.jsonnpx jpptr# 如果配置文件不存在，请给出路径npx jpptr ./src/jpptr.config.json 启动单个动作文件 1npx jpptr exec ./test.json ESM 启动配置文件 1234567891011121314import { Jpptr } from &quot;jpptr&quot;;import path from &quot;path&quot;;(async () =&gt; { /** * 启动配置文件 * 如果你的配置文件不是在根目录，请添加 __dirname 去定位文件的路径 * 或者使用 cwd 选项 * ```js * await Jpptr.launch(&quot;./jpptr.config.json&quot;,{cwd:__dirname}); * ``` */ await Jpptr.launch(&quot;./jpptr.config.json&quot;);})(); 启动单个文件 1234567891011121314151617181920import { Jpptr } from &quot;jpptr&quot;;import path from &quot;path&quot;;async function start() { /** * 实例化 jpptr * 如果你的json动作文件不是在根目录，请添加 __dirname 去定位文件的路径 * 或者使用 cwd 选项 * ```js * const jpptr = Jpptr.from(&quot;./test.json&quot;,{cwd:__dirname}); * ``` */ const jpptr = Jpptr.from(&quot;./test.json&quot;); /** 启动浏览器 */ const execute = await jpptr.createExecutor(); /** 执行全部动作 */ await execute.executeAll();}start(); commonjs 使用 require ， 其余操作跟 ESM 一样 123// @ts-checkconst { Jpptr } = require(&quot;jpptr&quot;);const path = require(&quot;path&quot;); 配置文件 配置文件用于指定需要执行的动作文件，以及一些全局配置 jpptr.config.json123456{ &quot;name&quot;: &quot;my jpptr config&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;include&quot;: [&quot;./src/**/*.json&quot;, &quot;./test.json&quot;], &quot;exclude&quot;: [&quot;node_modules/**/*&quot;]} 动作文件 一般带有 launch 启动参数，以及 actions 动作列表，的 json 文件，我们称为动作文件 launch : puppeteer 启动参数 actions : 动作列表 12345678910111213141516171819202122{ /** puppeteer 启动参数 */ &quot;launch&quot;: { &quot;executablePath&quot;: &quot;C:/Program Files/Google/Chrome/Application/chrome.exe&quot;, &quot;defaultViewport&quot;: null, &quot;headless&quot;: false }, &quot;actions&quot;: [ /** 跳转网址 */ [&quot;goto&quot;, &quot;https://enncy.github.io/jpptr/test.html&quot;], /** 填写表单 */ [&quot;type&quot;, &quot;#username&quot;, &quot;enncy&quot;], /** 填写表单 */ [&quot;type&quot;, &quot;#password&quot;, &quot;123456&quot;], /** 提交表单 */ [&quot;click&quot;, &quot;#submit&quot;], /** 等待3秒 */ [&quot;waitForTimeout&quot;, 3000] /** 关闭浏览器 */ [&quot;close&quot;] ]} 动作(Actions) 动作是 jpptr 的核心事件 一个动作对应着浏览器中的操作，例如点击，输入，跳转 动作可以表示成一个数组 ： [puppeteer 方法, …方法的其余参数] 1[&quot;goto&quot;, &quot;https://enncy.github.io/jpptr/test.html&quot;] jpptr 会使用 ArrayParser 将其解析成可以执行的动作对象 12345{ &quot;use&quot;: &quot;function&quot;, &quot;name&quot;: &quot;goto&quot;, &quot;args&quot;: [&quot;https://enncy.github.io/jpptr/test.html&quot;]} 其中 use : 是使用插件 function : 是 方法插件 专门执行 puppeteer 的方法 name : 是 puppeteer 的方法名 args : 是 puppeteer 方法名的参数列表 详细文档 : /jpptr-docs/action/ 解析器(Parser) 解析器用于解析 动作文件 详细文档 : /jpptr-docs/parser/ 插件(Plugin) 插件也可以解析 动作文件 插件有控制 puppeteer 的权限, 例如 browser, page, frame 等 插件可以返回新的 browser, page, frame 以及 actions(子动作) jpptr 会根据返回的 actions 继续生成新的动作，并且执行 详细文档 : /jpptr-docs/plugin/","link":"/jpptr-docs/"},{"title":"网课教程(1)  前言","text":"欢迎来到skeleton系列教程 ：网课脚本编写教程 什么是脚本？ 脚本（Script），是使用一种特定的描述性语言，依据一定的格式编写的可执行文件。 脚本语言又被称为扩建的语言, 或者动态语言, 是一种编程语言, 用来控制软件应用程序, 脚本通常是以文本 (ASCⅡ) 保存, 只是在被调用时进行解释或者编译。 我们可以在百度百科查询到上面一则简介，其中有句话是重点 是一种编程语言, 用来控制软件应用程序 什么是网课脚本？ 那么 网课 脚本 又是什么呢。用我这段时间接触的感受来说， 网课脚本，其实就是一种控制网络课程自动化运行的编程思想。 其目的是通过编写脚本，使得网络课程平台的任务自动化完成。 网课脚本怎么样实现？ 简而言之，脚本可以分为2种方式实现。 一： 通过编写自动化脚本，来达到实现网课自动运行 可以用来实现的语言有 语言 优点 缺点 javascript / jquery 轻量便捷，直接在浏览器上运行 权限不足，只能控制dom元素来实现自动化 java + selenium 权限高，能控制浏览器打开关闭，等等高级操作，拥有后端强大功能 难度较大，新手不好上手 python + selenium 权限高，一样能控制浏览器，并有后端功能， 作为python ， web服务当然比不过java ，如果需要做一套全自动 web 脚本系统，当然首选 java nodejs + selenium 同样拥有高级权限和各种功能，缺点就是社区生态不好，教程较少 教程很少，新手不好上手 nodejs + puppeteer (新框架) 推荐使用 puppeteer ，友好的 API ，和 selenium 一样，是爬虫框架。但是对 nodejs 支持非常友好 新框架的生态，社区会相对 selenium 弱 二： 通过http模拟请求，来控制网课的自动运行 此方式适用一切可以发送网络http请求的语言，只要能通过抓包分析网络请求，然后通过语言去模拟网课的网络请求，那么就可以实现自动化完成任务的目的。 优点： 完全脱离浏览器的限制，通过稳定的模拟网络请求，可以完美的完成自动化刷课的目的。 缺点： 难度极大，新手不建议尝试 。 如何学习？ 想要编写简单的网课脚本，需要先学习基础的 html+javascript + jquery 这3门语言 如果你没有学习以上3门技术，那么必须学完才能 编写网课脚本。 这里博主推荐一个众所周知的学习网站：https://www.bilibili.com/","link":"/2022/01/24/%E7%BD%91%E8%AF%BE/%E7%BD%91%E8%AF%BE%E6%95%99%E7%A8%8B(1)%20%20%E5%89%8D%E8%A8%80/"}],"tags":[{"name":"jpptr 文档","slug":"jpptr-文档","link":"/tags/jpptr-%E6%96%87%E6%A1%A3/"},{"name":"网课脚本","slug":"网课脚本","link":"/tags/%E7%BD%91%E8%AF%BE%E8%84%9A%E6%9C%AC/"},{"name":"脚本","slug":"脚本","link":"/tags/%E8%84%9A%E6%9C%AC/"}],"categories":[{"name":"jpptr","slug":"jpptr","link":"/categories/jpptr/"},{"name":"网课","slug":"网课","link":"/categories/%E7%BD%91%E8%AF%BE/"}]}